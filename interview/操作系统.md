### 1.什么是操作系统？ 

操作系统是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序。

### 2.操作系统的功能 

操作系统的功能主要可以分为以下5个部分 

- 处理器管理，主要控制和管理CPU的工作 
- 存储管理，主要进行内存的分配和管理 
- 设备管理，主要管理基本的输入输出设备 
- 文件管理，负责对计算机文件的组织、存储、操作和保护等 
- 进程管理（作业管理），对计算机所进行的操作进行管理

### 3.什么是用户态和内核态

用户态和内核态是操作系统的两种运行状态，操作系统主要是为了对访问能力进行限制，用户态的权限较低，而内核态的权限较高 

- 用户态：用户态运行的程序只能**受限地访问内存**，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的 CPU 不允许**独占**，也就是说 CPU 能够被其他程序获取。 
- 内核态：内核态运行的程序可以**访问计算机的任何数据和资源**，不受限制，包括外围设备，比如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生**抢占**情况。

### 4.❤用户态和内核态是如何切换的? 

先看为什么要进行切换 

用户程序是跑在用户态下的，但有时候会遇到一些操作需要比较高的权限，比如申请内存等，这时候就需要转换到内核态去做。  

内核态切换到用户态是通过设置程序状态字PSW 

导致用户态切换到内核态最主要有**三种场景** 

- **系统调用**，这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。 
- **异常**，当CPU执行运行在用户态下的程序时，发生了异常，这时会从当前的进程切换到处理异常的内核相关程序中，也就是从用户态切换到内核态，比如缺页异常 
- **外围设备的中断**，当外围设备完成用户请求的操作后，会像CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序

### 5.❤进程、线程和协程的区别和联系 

> 腾讯、得物24届秋招

这三者的区别是一个比一个”小“的，一个进程可以包含多个线程，一个线程也可以包含多个协程。 

- 进程：进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程 
- 线程：线程是程序执行的基本单位，是轻量级的进程 
- 协程：用户态轻量级线程，是一种比线程更加轻量级的存在，协程是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处继续运行 

值得注意的是，一个线程内的多个协程的运行是串行的，一个进程可以有一个或多个线程，同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈和线程本地存储，下面看下具体的区别

|          | 进程                       | 线程              | 协程    |
| -------- | ------------------------ | --------------- | ----- |
| 切换者      | 操作系统                     | 操作系统            | 用户    |
| 切换时机     | 操作系统的切换策略决定              | 操作系统的切换策略决定     | 用户决定  |
| 切换内容     | 页全局目录、内核栈、硬件上下文          | 内核栈、硬件上下文       | 硬件上下文 |
| 切换内容的保存  | 内核栈                      | 内核栈             | 内核栈/堆 |
| **切换过程** | 用户态-内核态-用户态              | 用户态-内核态-用户态     | 用户态   |
| 并发问题     | 不同进程之间切换实现并发，各自占有CPU实现并行 | 一个进程内部的多个线程并发执行 | 串行执行  |
| **系统开销** | 很大                       | 较小              | 很小    |

进程和线程的根本区别在于： **多进程中每个进程有自己的地址空间，线程则共享地址空间**。

### 6.Linux系统中一个进程可以创建多少线程 

这个主要和系统的位数有关系 

- 32位，用户态的虚拟空间只有 3G，假设创建一个线程需要占用 10M 虚拟内存，可以创建差不多 300 个（3G/10M）左右的线程 
- 64位，用户态的虚拟空间只有 128T，假设创建一个线程需要占用 10M 虚拟内存，可以创建差不多1000多万（128T/10M）左右的线程，当然了，这只是理论，实际上还会受到系统的参数或性能限制，可能会远远小于这个数值，具体还得取决于那你的系统吸能怎么样

### 7.什么是临界区，如何解决冲突？ 

每个进程中访问临界资源的那段程序称为临界区，一次仅允许一个进程使用的资源称为临界资源。 

解决冲突的办法： 

- 如果有若干进程要求进入空闲的临界区，**一次仅允许一个进程进入**，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待； 
- 进入临界区的进程要在有限时间内退出。 
- 如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象

### 8.并发和并行有什么区别 

- 并行：单位时间多个处理器同时处理多个任务。
- 并发：一个处理器处理多个任务，按时间片轮流处理多个任务。

### 9.什么是上下文切换？

上下文切换指的是内核操作系统的核心在CPU上对进程或者线程进行切换。 

搞清楚上下文切换需要先搞清楚什么是上下文 

CPU在开始执行任务时需要先知道从哪里去加载任务，从哪里开始执行，上下文的作用就是告诉CPU这些。（通常是由程序计数器和CPU寄存器来完成） 

那为什么需要上下文切换呢？ 

一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式，就是一个线程的时间片用完会退回到就绪态，其他线程继续运行，这个过程就是进行了一次上下文切换 

上下文切换的步骤： 

- 挂起一个进程，将这个进程在CPU中的状态（上下文信息）存储于内存的PCB（Process Control Block）中 
- 在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复 
- 最后跳转到程序计数器所指的新位置，运行新任务 

引起线程上下文切换的原因： 

（1）当前正在执行的任务完成，系统的CPU正常调度下一个任务。 

（2）当前正在执行的任务遇到I/O等阻塞操作，调度器挂起此任务，继续调度下一个任务。 （

（3）多个任务并发抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续调度下一个任务。 

（4）用户的代码挂起当前任务，比如线程执行yield()方法，让出CPU。 

（5）硬件中断。

上下文切换可以分为**进程上下文切换、线程上下文切换、中断上下文切换**三种 

- 进程上下文切换：进程上下文切换需要保存的东西比较多，花费的时间也比较多，进程的上下文主要包括虚拟内存、栈、全局变量、堆栈、寄存器等 线程上下文切换：
- 线程上下文切换时，虚拟内存和全局变量等资源都是共享的，线程的上下文包括栈和寄存器等，比寄存器少很多。 
- 中断上下文切换：为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，然后调用中断处理程序，响应设备事件。中断上下文，只包括内核态中断服务程序执行所必需的状态，也就是 CPU 寄存器、内核堆栈、硬件中断参数等

### 10.进程有哪些状态？ 

进程的状态模型一般可以分为三态模型和五态模型，这里以五态模型为例，三态模型指**就绪、运行、阻塞**（等待） 进程一共有以下几个状态： 

- 就绪状态：：进程具备运行条件，等待系统分配处理器以便运行的状态。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 
- 运⾏状态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。 
- 阻塞状态：又称等待态，指进程不具备运行条件，正在等待某个时间完成的状态。一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。 
- 创建状态：对应于进程被创建时的状态，尚未进入就绪队列。创建一个进程需要通过两个步骤：1.为新进程分配所需要的资源和建立必要的管理信息。2.设置该进程为就绪态，并等待被调度执行。
- 结束状态：：指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。 五种状态的转换过程如下：

![img](https://www.mianshi.online/wp-content/uploads/2022/09/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-1.png)

### 11.什么是僵尸进程？什么是孤儿进程？ 

僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。 

例如，当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程 系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。 

孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程。这些孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 

当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。也就是说孤儿进程可以正常退出，因此孤儿进程并不会有什么危害

### 12.如何避免僵尸进程？ 

- 让僵尸进程的父进程来回收，父进程每隔一段时间来查询子进程是否结束并回收，调用wait()或者waitpid(),通知内核释放僵尸进程 
- 采用信号SIGCHLD通知处理，并在信号处理程序中调用wait函数。父进程首先注册一个信号处理函数signal(SIGCHLD, sig_chld_handler)，然后每当子进程退出的时候父进程都会受到SIGCHLD信号， 触发sig_chld_handler()函数，调用wait()函数等待子进程的退出。 
- 让僵尸进程变成孤儿进程，由init回收。例如可以父进程首先创建子进程，子进程创建孙子进程，由孙子进程处理事务，而子进程再创建完孙子进程后，就退出。这样孙子进程就变成了孤儿进程。

### 13.❤进程有哪些调度算法？ 

> 腾讯24届秋招一面

先来说下什么是抢占式调度，什么式非抢占式调度 

抢占式调度：现行进程在运行过程中，如果有重要或紧迫的进程到达（其状态必须为就绪），则现运行进程将被迫放弃处理器，系统将处理器立刻分配给新到达的进程 

非抢占式调度：非抢占式让原来正在运行的进程继续运行，直至该进程完成或发生某种事件（如I/O请求），才主动放弃处理机 

**先来先服务（FCFS，first come first served）** 

非抢占式调度算法，这是最简单的一种调度算法，比较好理解，就是根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间。 

优点：公平，实现简单 缺点：比较有利于长作业，而不利于短作业 

**时间片轮转（RR，Round-Robin）** 

抢占式调度，给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，适用于分时系统。 

优点：兼顾长短作业 缺点：平均等待时间较长，上下文切换较费时

**短作业优先（SJF, Shortest Job First）** 

非抢占式调度算法，对预计执行时间短的进程优先处理。对应的还有最短剩余时间优先算法，这是类似抢占式的短作业优先算法 

优点：相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量

缺点：不利于长作业 

**高响应比优先（HRRN，Highest Response Ratio Next）** 

非抢占式调度算法，最高响应比是一种折中的算法，先来先服务主要考虑的是作业的等待时间而未考虑到作业的执行时间，短作业优先主要考虑的是作业的执行时间而未考虑作业等待时间。而最高响应比同时考虑到了两者，其响应比=（预估的进程执行时间+进程等待时间）/ 预估的进程执行时间，这就保证了等待时间相同的情况下，作业执行的时间越短，响应比越高，同时响应比会随着等待时间减小而变大，优先级会提高，能够避免饥饿现象，适用于批处理系统。 

优点：兼顾长短作业 缺点：计算响应比开销大 

**优先级调度算法**

抢占式调度算法，在进程等待队列中选择优先级最高的来执行。 

**多级反馈队列（Multilevel Feedback Queue）** 

抢占式调度算，这是一种将时间片轮转和优先级调度想结合的算法，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转 

优点：兼顾长短作业，有较好的响应时间，可行性强



### 14.线程和进程都怎么通信？

> 一般面试问的是进程间的通信
>
> 得物、滴滴

线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。

进程间的通信则不同，它的数据空间的独立性决定了它的通信相对比较复杂，需要通过操作系统。以前进程间的通信只能是单机版的，现在操作系统都继承了基于套接字（socket）的进程间的通信机制。这样进程间的通信就不局限于单台计算机了，实现了网络通信。

进程间的通信方式
- **管道( pipe )**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。


- **有名管道 (namedpipe)** ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。


- **信号量(semophore )** ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。


- **消息队列( messagequeue )** ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。


- 信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。


- **共享内存**(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。


- **套接字(socket )** ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机间的进程通信。

线程间的通信方式

- **锁机制**：包括互斥锁、条件变量、读写锁

  - 互斥锁提供了以排他方式防止数据结构被并发修改的方法。


  - 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。


  - 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

- **信号量机制**(Semaphore)：包括无名线程信号量和命名线程信号量

- **信号机制**(Signal)：类似进程间的信号处理

- 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

### 15.❤简述多路IO复用技术

> 参考https://www.jianshu.com/p/111f079315f5

IO 多路复用是一种同步 IO 模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出 cpu。

IO 是指网络 IO，多路指多个 [TCP](https://www.jianshu.com/p/cae79a66af4a) 连接(即 socket 或者 channel)，复用指复用一个或几个[线程](https://www.jianshu.com/p/6a4947e27114)。意思说一个或一组线程处理多个 TCP 连接。最大优势是减少系统开销，不必创建过多的[进程/线程](https://www.jianshu.com/p/94b7c2ab84ac)，也不必维护这些进程/线程。

IO 多路复用的三种实现方式：select、poll、epoll。

**select 机制**

1️⃣基本原理：
客户端操作服务器时就会产生这三种文件描述符(简称fd)：writefds(写)、readfds(读)、和 exceptfds(异常)。select 会阻塞住监视 3 类文件描述符，等有数据、可读、可写、出异常或超时就会返回；返回后通过**遍历** fdset 整个数组来找到就绪的描述符 fd，然后进行对应的 IO 操作。

2️⃣优点：
几乎在所有的平台上支持，跨平台支持性好

3️⃣缺点：

1. 由于是采用轮询方式全盘扫描，会随着文件描述符 FD 数量增多而性能下降。
2. 每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)。
3. 单个进程打开的 FD 是有限制(通过`FD_SETSIZE`设置)的，默认是 1024 个，可修改宏定义，但是效率仍然慢。

**poll 机制**

1️⃣基本原理与 select 一致，也是**轮询+遍历**。唯一的区别就是 poll 没有**最大文件描述符限制**(使用[链表](https://www.jianshu.com/p/81a6ed0abeb8)的方式存储 fd)。

2️⃣poll 缺点

1. 由于是采用轮询方式全盘扫描，会随着文件描述符 FD 数量增多而性能下降。
2. 每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)。

**epoll机制**

1️⃣基本原理：
没有 fd 个数限制，用户态拷贝到内核态只需要一次，使用**时间通知机制**来触发。通过 epoll_ctl 注册 fd，一旦 fd 就绪就会通过 callback 回调机制来激活对应 fd，进行相关的 io 操作。
epoll 之所以高性能是得益于它的三个函数：

1. epoll_create() 系统启动时，在 Linux 内核里面申请一个基于**红黑树**结构的文件系统，返回 epoll 对象，也是一个 fd。
2. epoll_ctl() 每新建一个连接，都通过该函数操作 epoll 对象，在这个对象里面修改添加删除对应的链接 fd，绑定一个 callback 函数
3. epoll_wait() 轮训所有的callback集合，并完成对应的 IO 操作

2️⃣优点：
没 fd 这个限制，所支持的 FD 上限是操作系统的最大文件句柄数，1G 内存大概支持 10 万个句柄。效率提高，使用回调通知而不是轮询的方式，不会随着 FD 数目的增加效率下降。内核和用户空间 mmap 同一块内存实现(mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间)

3️⃣epoll缺点：
epoll 只能工作在 [linux](https://www.jianshu.com/p/95d087dc1a43) 下。

4️⃣epoll 应用：**redis、nginx**

### 16.简述进程切换的流程

1.切换页目录以使用新的地址空间

2.切换内核栈和硬件上下文

### 17.抢占是如何做到的

-  **两种情况**

  -  进程的时间片用完了，
  -  [优先级](https://so.csdn.net/so/search?q=%E4%BC%98%E5%85%88%E7%BA%A7&spm=1001.2101.3001.7020)更高的进程来争夺CPU了。

-  **抢占的过程**分两步，第一步触发抢占，第二步执行抢占，这两步中间不一定是连续的，有些特殊情况下甚至会间隔相当长的时间：

1. 触发抢占：给正在CPU上运行的当前进程设置一个请求重新调度的标志(TIF_NEED_RESCHED)，仅此而已，此时进程并没有切换。

2. 执行抢占：在随后的某个时刻，内核会检查TIF_NEED_RESCHED标志并调用schedule()执行抢占。

   抢占只在某些特定的时机发生，这是内核的代码决定的。

- **抢占时机**: 让进程调用 `__schedule`, 分为用户态和内核态
    - 用户态进程
        - 时机-1: 从系统调用中返回, 返回过程中会调用 exit_to_usermode_loop, 检查 `_TIF_NEED_RESCHED`, 若打了标记, 则调用 schedule()
        - 时机-2: 从中断中返回, 中断返回分为返回用户态和内核态(汇编代码: arch/x86/entry/entry_64.S), 返回用户态过程中会调用 exit_to_usermode_loop()->shcedule()
    - 内核态进程
        - 时机-1: 当内核从non-preemptible（禁止抢占）状态变成preemptible（允许抢占）的时候；
        - 时机-2: 发生在中断返回, 也会调用 `__schedule`

### 18.什么是字节对齐

> 滴滴一面

所谓的字节对齐，就是各种类型的数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这个就是对齐。我们经常听说的对齐在N上（即一个变量在内存中占用N字节），它的含义就是数据的存放起始地址%N==0。

为什么要字节对齐？

各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些[架构](http://lib.csdn.net/base/16)的CPU，诸如SPARC在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构上必须编程必须保证字节对齐。

而有些平台对于没有进行对齐的数据进行存取时会产生效率的下降，如下：



![img](https://img-blog.csdnimg.cn/2020031416375071.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70)

### 19.什么是页表，页表的作用？

> 滴滴一面

页表是一种特殊的[数据结构](https://hd.nowcoder.com/link.html?target=https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450)，放在系统空间的页表区，存放逻辑页与物理页帧的对应关系。 每一个[进程](https://hd.nowcoder.com/link.html?target=https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B/382503)都拥有一个自己的页表，[PCB](https://hd.nowcoder.com/link.html?target=https://baike.baidu.com/item/PCB/16067368)表中有指针指向页表。
页表的作用：是内存非连续分区分配的基础，实现从[逻辑地址](https://so.csdn.net/so/search?q=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80&spm=1001.2101.3001.7020)转化成物理地址。

为什么不直接使用物理内存？

- 安全风险：每个进程都可以访问0-4G的任意的内存空间，这也就意味着任意一个进程都能够去读写系统相关内存区域，如果是一个

  木马病毒，那么他就能随意的修改内存空间，让设备直接瘫痪

- 用户可以访问任意的内存，寻址内存的每个字节，这样容易破坏操作系统，造成操作系统崩溃。

- 想要同时运行多个程序特别困难。 

### 20.讲讲你对操作系统内存的理解

> 滴滴暑期实习一面
>
> [操作系统之内存管理，啃完的人都超神了！！！ - 掘金 (juejin.cn)](https://juejin.cn/post/6942662689546059807#heading-17)

- **首先什么是内存**

  - 内存就是许多 RAM 存储器的集合，就是将许多 RAM 存储器集成在一起的电路板。RAM 存储器的优点是存取速度快、读写方便。系统中会有一个或多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。
  - 系统会将程序编译链接成可执行模块加载进内存执行，有两种链接模式，静态链接（在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行文件(装入模块)，即得到完整的逻辑地址，之后不再拆开）和动态链接（运行该目标模块时，才对它进行链接，用不到的模块不需要装入内存）。

- **内存分配。**

  - 连续分配（在单一连续分配方式中，内存被分为系统区和用户区。内存中只能有一道用户程序，用户程序独占整个用户区空间。）
  - 动态分区分配（在进程装入内存时， 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要）。

  ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66036030e9e1447696fe77f154185090~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)


- **内存管理**
  - 分页：操作系统会为每一个进程维护一张页表(pagetable)，页表中记录着从逻辑地址到物理地址的映射，即页到帧的映射
  - 快表（TLB）:是一种访问速度比内存快很多的高速缓存(TLB不是内存!)，用来存放最近访问的页表项的副本，可以加速地址变换的速度


- **虚拟地址**
  - 虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的，虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)
  - ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d499b9256754d3b917251bb048d7740~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 21.❤为什么要有虚拟内存(虚拟内存有什么作用)？

> 滴滴三面

- 虚拟内存可以使得进程对运行内存**超过物理内存**大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
- 由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是**相互独立**的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间**地址冲突**的问题。
- 页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的**安全性**。

### 22.操作系统内存紧张时会发生什么？

内核在给应用程序分配物理内存的时候，如果空闲物理内存不够，那么就会进行内存回收的工作，主要有两种方式：

- **后台内存回收**：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程**异步**的，不会阻塞进程的执行。
- **直接内存回收**：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。

可被回收的内存类型有文件页和匿名页：

- 文件页的回收：对于干净页是直接释放内存，这个操作不会影响性能，而对于脏页会先写回到磁盘再释放内存，这个操作会发生磁盘 I/O 的，这个操作是会影响系统性能的。
- 匿名页的回收：如果开启了 Swap 机制，那么 Swap 机制会将不常访问的匿名页换出到磁盘中，下次访问时，再从磁盘换入到内存中，这个操作是会影响系统性能的。

文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。回收内存的操作基本都会发生磁盘 I/O 的，如果回收内存的操作很频繁，意味着磁盘 I/O 次数会很多，这个过程势必会影响系统的性能。

在经历完直接内存回收后，空闲的物理内存大小依然不够，那么就会触发 **OOM 机制**，OOM killer 就会根据每个进程的内存占用情况和 oom_score_adj 的值进行打分，得分最高的进程就会被首先杀掉。

我们可以通过调整进程的 /proc/[pid]/oom_score_adj 值，来降低被 OOM killer 杀掉的概率。



### 23.操作系统如何避免预读失效和缓存污染的问题？

**什么是预读机制：**

Linux 操作系统为基于 Page Cache 的读缓存机制提供**预读机制**，一个例子是：

- 应用程序只想读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。
- 但是操作系统出于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page；

如果**这些被提前加载进来的页，并没有被访问**，相当于这个预读工作是白做了，这个就是**预读失效**。如果这些「预读页」如果一直不会被访问到，就会出现一个很奇怪的问题，**不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率** 。

**什么是缓存污染：**

当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，**如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了**。

**解决问题：**

- Linux 操作系统实现两个了 LRU 链表：**活跃 LRU 链表（active list）和非活跃 LRU 链表（inactive list）**。

但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么**还存在缓存污染的问题**。

为了避免「缓存污染」造成的影响，Linux 操作系统提高了升级为热点数据的门槛：

- Linux 操作系统：在内存页被访问**第二次**的时候，才将页从 inactive list 升级到 active list 里。

通过提高了进入 active list的门槛后，就很好了避免缓存污染带来的影响。

### 24.进程写文件时，进程发生了崩溃，已写入的数据会丢失吗

当进程在写文件过程中发生崩溃时，已写入的数据有**可能会丢失**。这取决于文件系统和操作系统的特性以及应用程序的写入策略。

在一般情况下，当进程写入数据时，数据首先被缓存内核的 **page cache**，它是文件系统中用于缓存文件数据的缓冲，然后才会被操作系统写入磁盘。如果进程在数据被写入磁盘之前发生崩溃，那么这部分尚未写入磁盘的数据将会丢失。

要确保数据的持久化，可以采取以下措施：

1. **同步写入**：在写入数据后，可以使用操作系统提供的同步写入函数（如`fsync`或`fdatasync`）将数据立即刷写到磁盘。这样可以确保数据被持久化保存，但会影响性能，因为需要等待磁盘写入完成才能继续执行。
2. **缓冲区刷新**：使用缓冲区和缓冲区刷新策略，将数据缓存在内存中，并**定期**将缓冲区中的数据刷新到磁盘。可以通过设置适当的缓冲区大小和刷新策略来平衡性能和数据持久化的要求。在此方法下，仍然存在在进程崩溃前数据未被刷新到磁盘的风险。
3. 使用事务或日志：对于需要保证数据一致性和持久化的场景，可以使用事务或日志来记录数据的操作。通过将数据操作记录到事务日志中，即使在进程崩溃后，可以通过回滚或恢复日志来恢复之前的数据状态。比如Journaled 文件系统。
4. 定期备份：定期进行数据备份，将数据拷贝到其他存储介质或远程位置。这样即使在进程崩溃时，可以使用备份来恢复数据。比如RAID 阵列

需要根据具体的应用场景和数据重要性来选择适当的数据持久化策略。确保及时备份数据和采取适当的容灾措施是保护数据安全的重要措施之一。

### 25.多路IO复用中epoll机制的 LT 模式和 ET 模式

与 poll 的事件宏相比，epoll 新增了一个事件宏 **EPOLLET**，这就是所谓的**边缘触发模式**（**E**dge **T**rigger，ET），而默认的模式我们称为 **水平触发模式**（**L**evel **T**rigger，LT）。这两种模式的区别在于：

- 对于水平触发模式，**一个事件只要有，就会一直触发**；
- 对于边缘触发模式，**只有一个事件从无到有才会触发**。

以 **socket 的读事件**为例，对于水平模式，只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件；而对于边缘模式，socket 上每新来一次数据就会触发一次，如果上一次触发后，未将 socket 上的数据读完，也不会再触发，除非再新来一次数据。对于 socket 写事件，如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；而对于边缘模式，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。

边缘触发模式可以减少通知次数，适用于需要高效处理事件的场景，但需要确保在通知之后将所有就绪数据读取完毕。水平触发模式则更加简单，适用于处理非阻塞的场景，但需要在处理就绪事件时小心防止事件被重复通知。

需要注意的是，边缘触发模式需要更加细致的处理，以免错过就绪事件或者陷入死循环。对于初学者来说，水平触发模式更容易理解和使用。